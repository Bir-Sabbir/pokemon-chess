<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pokémon Chess — 3D Canvas (Billboard Sprites + Team Colors)</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial; background: #0e0f13; color: #e6e6e6; }
    .app { display: grid; grid-template-columns: minmax(300px, 70vmin) 1fr; gap: 20px; padding: 16px; }
    #boardWrap { position: relative; aspect-ratio: 1 / 1; background: #0b0c11; border: 2px solid #2a2d3a; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.35); overflow: hidden; }
    #board { width: 100%; height: 100%; display: block; }
    .side { display: grid; grid-template-rows: auto auto 1fr auto; gap: 14px; min-width: 280px; }
    .card { background: #141621; border: 1px solid #242738; border-radius: 12px; padding: 12px 14px; box-shadow: 0 6px 18px rgba(0,0,0,.25); }
    .title { font-weight: 700; letter-spacing: 0.2px; margin-bottom: 8px; }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    button { appearance: none; background: #2a2f44; color: #e6e6e6; border: 1px solid #3b4160; border-radius: 10px; padding: 10px 14px; font-weight: 600; cursor: pointer; transition: transform .04s ease, background .2s ease, border-color .2s ease; }
    button:hover { background: #323959; border-color: #4c5686; }
    button:active { transform: translateY(1px); }
    .pill { display: inline-flex; gap: 8px; align-items: center; padding: 6px 10px; border-radius: 999px; background: #1e2030; border: 1px solid #2f334b; font-size: 13px; }
    .log { height: 320px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 13px; line-height: 1.5; white-space: pre-wrap; }
    .tiny { font-size: 12px; opacity: .9; }
    .badge { font-weight: 700; }
    .hr { height: 1px; background: #242738; margin: 8px 0; }
    .disclaimer { color: #aeb5cc; font-size: 11.5px; opacity: .85; }
  </style>
  <!-- three.js (non-module build) -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>
</head>
<body>
  <div class="app">
    <div id="boardWrap">
      <canvas id="board"></canvas>
    </div>

    <div class="side">
      <div class="card">
        <div class="title">Pokémon Chess — 3D Canvas</div>
        <div class="row">
          <div class="pill" id="turnPill">Turn: <span class="badge" id="turnText" style="margin-left:6px;">White</span></div>
          <div class="pill">Mode: <span class="badge" style="margin-left:6px;">Local 2P</span></div>
        </div>
        <div class="hr"></div>
        <div id="pieceInfo" class="tiny"></div>
      </div>

      <div class="card">
        <div class="title">Actions</div>
        <div class="row">
          <button id="newGameBtn">New Game</button>
          <button id="undoBtn">Undo</button>
          <button id="flipBtn">Flip Board</button>
          <button id="toggleSpritesBtn">Sprites: On</button>
          <button id="runTestsBtn">Run Tests</button>
        </div>
      </div>

      <div class="card">
        <div class="title">Move Log</div>
        <div id="log" class="log"></div>
      </div>

      <div class="card tiny">
        <div class="title">Notes</div>
        <ul>
          <li>3D scene: board + glowing team bases, sprites as billboards that face the camera.</li>
          <li><b>White = Blue team</b>, <b>Black = Red team</b> (tinted sprites + colored base).</li>
          <li>Click squares to move. Captures give XP; evolution updates the billboard with effects.</li>
        </ul>
        <div class="disclaimer">Pokémon sprites from PokéAPI (©Nintendo/Creatures/GAME FREAK). This is a fan-made educational demo.</div>
      </div>
    </div>
  </div>

<script>
(function(){
  // ====== Config ======
  const SQUARES = 8;
  const BOARD_Y = 0;     // y height of board plane
  const TILE = 1;        // 1 unit per square
  const HALF = (SQUARES-1)/2;

  // team styling (white=blue, black=red)
  const SIDE_STYLE = {
    white: { baseColor: 0x3b82f6, tint: 0x7bb0ff, ring: 0x5aa2ff },
    black: { baseColor: 0xef4444, tint: 0xff9a9a, ring: 0xff6b6b }
  };

  const XP_THRESHOLDS = [1,3]; // evolve at 1 and 3 captures

  // ====== DOM ======
  const canvas = document.getElementById('board');
  const boardWrap = document.getElementById('boardWrap');
  const logEl = document.getElementById('log');
  const turnText = document.getElementById('turnText');
  const pieceInfo = document.getElementById('pieceInfo');

  // ====== 3D Scene ======
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  const scene = new THREE.Scene();
  scene.background = null;

  // Camera – slight isometric angle
  const camera = new THREE.PerspectiveCamera(40, 1, 0.1, 100);
  camera.position.set(6.5, 9, 7.5);
  camera.lookAt(0, BOARD_Y, 0);

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.7));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,10,7); scene.add(dir);

  // Board: 64 tiles as individual meshes for picking
  const boardGroup = new THREE.Group();
  scene.add(boardGroup);
  const lightMat = new THREE.MeshStandardMaterial({color:0xc0cad6, roughness:0.9, metalness:0.05});
  const darkMat  = new THREE.MeshStandardMaterial({color:0x6a7a91, roughness:0.95, metalness:0.03});
  const geom = new THREE.BoxGeometry(TILE, 0.05, TILE);
  const squares = []; // for raycasting
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const mat = ((r+c)%2===0)? lightMat : darkMat;
      const m = new THREE.Mesh(geom, mat.clone());
      m.position.set(c-HALF, BOARD_Y-0.03, r-HALF);
      m.userData = { r, c };
      boardGroup.add(m); squares.push(m);
    }
  }

  // Square highlights (selection + legal moves)
  const highlightGroup = new THREE.Group(); scene.add(highlightGroup);
  const legalGroup = new THREE.Group(); scene.add(legalGroup);

  function setSquareHighlight(r,c,color){
    highlightGroup.clear();
    if (r==null) return;
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.98,0.98), new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.35, side:THREE.DoubleSide}));
    plane.rotation.x = -Math.PI/2; plane.position.set(c-HALF, BOARD_Y+0.03, r-HALF);
    highlightGroup.add(plane);
  }
  function setLegalHighlights(list,color){
    legalGroup.clear();
    for (const [r,c] of list){
      const ring = new THREE.Mesh(new THREE.RingGeometry(0.20, 0.28, 24), new THREE.MeshBasicMaterial({color, transparent:true, opacity:0.85, side:THREE.DoubleSide}));
      ring.rotation.x = -Math.PI/2; ring.position.set(c-HALF, BOARD_Y+0.04, r-HALF);
      legalGroup.add(ring);
    }
  }

  // Texture loader for sprites
  const loader = new THREE.TextureLoader();
  loader.setCrossOrigin('anonymous');

  // Sprite cache
  const SpriteCache = new Map();
  const SPRITE_BASE = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon';
  function spriteURL(id){ return `${SPRITE_BASE}/${id}.png`; }
  function loadTextureById(id, tintHex){
    const key = `${id}:${tintHex||0}`;
    if (SpriteCache.has(key)) return SpriteCache.get(key);
    const tex = loader.load(spriteURL(id));
    tex.magFilter = THREE.NearestFilter; tex.minFilter = THREE.LinearMipmapLinearFilter;
    SpriteCache.set(key, tex);
    return tex;
  }

  // Pokémon lines per piece type/color
  const PokeLines = {
    white: {
      pawn:   ['Bulbasaur','Ivysaur','Venusaur'],
      rook:   ['Onix','Steelix','Steelix'],
      knight: ['Pichu','Pikachu','Raichu'],
      bishop: ['Ralts','Kirlia','Gardevoir'],
      queen:  ['Eevee','Sylveon','Sylveon'],
      king:   ['Mew','Mew','Mew']
    },
    black: {
      pawn:   ['Charmander','Charmeleon','Charizard'],
      rook:   ['Geodude','Graveler','Golem'],
      knight: ['Tyrogue','Hitmonlee','Hitmonchan'],
      bishop: ['Gastly','Haunter','Gengar'],
      queen:  ['Eevee','Umbreon','Umbreon'],
      king:   ['Mewtwo','Mewtwo','Mewtwo']
    }
  };
  const POKE_ID = { Bulbasaur:1, Ivysaur:2, Venusaur:3, Charmander:4, Charmeleon:5, Charizard:6, Onix:95, Steelix:208, Geodude:74, Graveler:75, Golem:76, Pichu:172, Pikachu:25, Raichu:26, Tyrogue:236, Hitmonlee:106, Hitmonchan:107, Ralts:280, Kirlia:281, Gardevoir:282, Gastly:92, Haunter:93, Gengar:94, Eevee:133, Sylveon:700, Umbreon:197, Mew:151, Mewtwo:150 };

  // ====== 3D piece factory ======
  const pieceObjects = new Map(); // id -> THREE.Group
  function boardToWorld(r,c){ return new THREE.Vector3(c-HALF, BOARD_Y+0.10, r-HALF); }

  function make3DPiece(piece){
    const group = new THREE.Group();

    // Base cylinder with team color
    const style = SIDE_STYLE[piece.color];
    const baseGeo = new THREE.CylinderGeometry(0.34, 0.36, 0.18, 24);
    const baseMat = new THREE.MeshStandardMaterial({color: style.baseColor, emissive: style.baseColor, emissiveIntensity: 0.25, metalness: 0.2, roughness: 0.6});
    const base = new THREE.Mesh(baseGeo, baseMat); base.castShadow=false; base.receiveShadow=true; group.add(base);

    // Vertical banner (subtle)
    const banner = new THREE.Mesh(new THREE.PlaneGeometry(0.7, 0.28), new THREE.MeshBasicMaterial({color: style.baseColor, transparent:true, opacity:0.18}));
    banner.position.set(0, 0.28, 0); group.add(banner);

    // Sprite billboard
    const name = piece.line[piece.stage-1];
    const id = POKE_ID[name];
    const tex = loadTextureById(id);
    const sprMat = new THREE.SpriteMaterial({map: tex, color: new THREE.Color(style.tint)});
    const spr = new THREE.Sprite(sprMat);
    spr.scale.set(0.8, 0.8, 1);
    spr.position.y = 0.55; // above base
    group.add(spr);

    // For animations
    group.userData = { spr, base, banner, t0: performance.now(), bounceSeed: Math.random()*1000 };

    // Initial placement
    const p = boardToWorld(piece.row, piece.col);
    group.position.copy(p);

    scene.add(group);
    pieceObjects.set(piece.id, group);
  }

  function remove3DPiece(id){ const g = pieceObjects.get(id); if (g){ scene.remove(g); g.traverse(o=>{ if (o.geometry) o.geometry.dispose && o.geometry.dispose(); if (o.material) { if (Array.isArray(o.material)) o.material.forEach(m=>m.dispose&&m.dispose()); else o.material.dispose&&o.material.dispose(); }}); pieceObjects.delete(id);} }

  function update3DPiece(piece){
    // if new create; if existing update sprite/position
    if (!pieceObjects.has(piece.id)) make3DPiece(piece);
    const g = pieceObjects.get(piece.id);
    const style = SIDE_STYLE[piece.color];

    // update position
    const target = boardToWorld(piece.row, piece.col);
    g.position.lerp(target, 0.35);

    // idle motion + turn pulse
    const now = performance.now();
    const ud = g.userData; const t = (now - ud.t0 + ud.bounceSeed) / 650;
    const isTurn = (turn===piece.color);
    const bounce = Math.sin(t*2*Math.PI) * (isTurn? 0.05 : 0.03);
    g.position.y = BOARD_Y + 0.10 + bounce;

    // evolution pulse
    if (piece.anim && piece.anim.type==='evolve'){
      const a = 0.6 + 0.4*Math.sin((now-piece.anim.start)/70);
      ud.base.material.emissiveIntensity = 0.25 + 0.25*a;
      if (!piece.anim._burst){ spawnBurst(g.position.x, g.position.y+0.4, g.position.z, style.baseColor); piece.anim._burst=true; }
      if (now - piece.anim.start > 360) { piece.anim=null; ud.base.material.emissiveIntensity=0.25; }
    }

    // movement streak handled via particles briefly
    if (piece.anim && piece.anim.type==='move'){
      const dt = (now-piece.anim.start)/220; if (dt>1) piece.anim=null; else emitTrail(g.position, style.ring, 0.02);
    }

    // sprite update if stage changed
    const expectedId = POKE_ID[piece.line[piece.stage-1]];
    if (ud.lastSpriteId !== expectedId){
      ud.spr.material.map = loadTextureById(expectedId);
      ud.spr.material.needsUpdate = true;
      ud.lastSpriteId = expectedId;
    }

    // make banner always face camera horizontally
    ud.banner.lookAt(new THREE.Vector3(camera.position.x, ud.banner.position.y + g.position.y, camera.position.z));
  }

  // Simple particle system
  const particleGroup = new THREE.Group(); scene.add(particleGroup);
  const particles = [];
  function spawnBurst(x,y,z,color){
    for (let i=0;i<14;i++){
      const g = new THREE.SphereGeometry(0.04, 8, 8);
      const m = new THREE.MeshBasicMaterial({color, transparent:true, opacity:1});
      const s = new THREE.Mesh(g,m);
      s.position.set(x, y, z);
      const ang = Math.random()*Math.PI*2; const sp=0.03+Math.random()*0.06;
      const vy = 0.02+Math.random()*0.05;
      particleGroup.add(s);
      particles.push({mesh:s, vx:Math.cos(ang)*sp, vz:Math.sin(ang)*sp, vy, life:500+Math.random()*400, t0:performance.now()});
    }
  }
  function emitTrail(pos,color,opacity){
    const g = new THREE.SphereGeometry(0.03, 6, 6);
    const m = new THREE.MeshBasicMaterial({color, transparent:true, opacity});
    const s = new THREE.Mesh(g,m); s.position.copy(pos); particleGroup.add(s);
    particles.push({mesh:s, vx:0, vz:0, vy:0.01, life:180, t0:performance.now()});
  }
  function updateParticles(){
    const now = performance.now();
    for (let i=particles.length-1;i>=0;i--){
      const p=particles[i]; const t=(now-p.t0)/p.life; if (t>=1){ particleGroup.remove(p.mesh); p.mesh.geometry.dispose(); p.mesh.material.dispose(); particles.splice(i,1); continue; }
      p.mesh.position.x += p.vx; p.mesh.position.z += p.vz; p.mesh.position.y += p.vy; p.mesh.material.opacity = 1 - t;
    }
  }

  // ====== Helpers ======
  const deepClone = (o)=> JSON.parse(JSON.stringify(o));
  const inBounds = (r,c)=> r>=0 && r<8 && c>=0 && c<8;
  const algebra = (c,r)=> String.fromCharCode(97+c)+(8-r);
  const opposite = (color)=> color==='white' ? 'black' : 'white';

  function makeEmptyBoard(){ return Array.from({length:8},()=>Array(8).fill(null)); }
  function makePiece(type,color,row,col){
    const line = PokeLines[color][type];
    return { id:`${type}-${color}-${Math.random().toString(36).slice(2,8)}`, type, color, row, col, stage:1, xp:0, line, hasMoved:false, anim:null };
  }

  function startingPosition(){
    const b = makeEmptyBoard();
    for (let c=0;c<8;c++) b[6][c] = makePiece('pawn','white',6,c);
    b[7][0]=makePiece('rook','white',7,0); b[7][7]=makePiece('rook','white',7,7);
    b[7][1]=makePiece('knight','white',7,1); b[7][6]=makePiece('knight','white',7,6);
    b[7][2]=makePiece('bishop','white',7,2); b[7][5]=makePiece('bishop','white',7,5);
    b[7][3]=makePiece('queen','white',7,3);  b[7][4]=makePiece('king','white',7,4);

    for (let c=0;c<8;c++) b[1][c] = makePiece('pawn','black',1,c);
    b[0][0]=makePiece('rook','black',0,0); b[0][7]=makePiece('rook','black',0,7);
    b[0][1]=makePiece('knight','black',0,1); b[0][6]=makePiece('knight','black',0,6);
    b[0][2]=makePiece('bishop','black',0,2); b[0][5]=makePiece('bishop','black',0,5);
    b[0][3]=makePiece('queen','black',0,3);  b[0][4]=makePiece('king','black',0,4);
    return b;
  }

  // ====== Attacks / legal moves ======
  function locateKing(board, color){ for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p=board[r][c]; if (p && p.type==='king' && p.color===color) return [r,c]; } return null; }
  function attacksFor(board,piece){
    const {type,color,row,col}=piece; const out=[]; const dir=color==='white'?-1:1;
    if (type==='pawn'){ for (const dc of [-1,1]){ const r=row+dir,c=col+dc; if (inBounds(r,c)) out.push([r,c]); } return out; }
    if (type==='knight'){ const ds=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]; for (const [dr,dc] of ds){ const r=row+dr,c=col+dc; if (inBounds(r,c)) out.push([r,c]); } return out; }
    const rays=[]; if (type==='bishop'||type==='queen') rays.push([1,1],[1,-1],[-1,1],[-1,-1]); if (type==='rook'||type==='queen') rays.push([1,0],[-1,0],[0,1],[0,-1]); if (type==='king') rays.push([1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]);
    for (const [dr,dc] of rays){ let r=row+dr,c=col+dc; while(inBounds(r,c)){ out.push([r,c]); if (board[r][c]||type==='king') break; r+=dr; c+=dc; } }
    return out; }
  function isSquareAttacked(board,r,c,byColor){ for (let i=0;i<8;i++) for (let j=0;j<8;j++){ const p=board[i][j]; if (!p||p.color!==byColor) continue; const atks=attacksFor(board,p); for (const [ar,ac] of atks){ if (ar===r&&ac===c) return true; } } return false; }
  function legalize(board,piece,moves){ const out=[]; for (const [r,c] of moves){ const sim=deepClone(board); const p=sim[piece.row][piece.col]; sim[r][c] = {...p, row:r, col:c, hasMoved:true}; sim[piece.row][piece.col]=null; const [kr,kc]=locateKing(sim,piece.color); if (!isSquareAttacked(sim,kr,kc,opposite(piece.color))) out.push([r,c]); } return out; }
  function generateMoves(board,piece){ const {type,color,row,col}=piece; const dir=color==='white'?-1:1; const raw=[]; if (type==='pawn'){ const f1r=row+dir, f1c=col; if (inBounds(f1r,f1c) && !board[f1r][f1c]){ raw.push([f1r,f1c]); const startRow=color==='white'?6:1; const f2r=row+2*dir; if (row===startRow && !board[f2r][f1c]) raw.push([f2r,f1c]); } for (const dc of [-1,1]){ const r=row+dir,c=col+dc; if (!inBounds(r,c)) continue; const t=board[r][c]; if (t && t.color!==color) raw.push([r,c]); } return legalize(board,piece,raw); } if (type==='knight'){ const ds=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]]; for (const [dr,dc] of ds){ const r=row+dr,c=col+dc; if (!inBounds(r,c)) continue; const t=board[r][c]; if (!t||t.color!==color) raw.push([r,c]); } return legalize(board,piece,raw); } const rays=[]; if (type==='bishop'||type==='queen') rays.push([1,1],[1,-1],[-1,1],[-1,-1]); if (type==='rook'||type==='queen') rays.push([1,0],[-1,0],[0,1],[0,-1]); if (type==='king') rays.push([1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]); for (const [dr,dc] of rays){ let r=row+dr,c=col+dc; while(inBounds(r,c)){ const t=board[r][c]; if (!t) raw.push([r,c]); else { if (t.color!==color) raw.push([r,c]); break; } if (type==='king') break; r+=dr; c+=dc; } } return legalize(board,piece,raw); }

  // ====== Game State ======
  let boardState = startingPosition();
  let turn = 'white';
  let selected = null; let legal = []; let lastMove = null; let history=[]; let flipped=false; let useSprites=true;

  // Build initial 3D pieces
  function rebuildAllPieces(){
    // clear
    for (const id of Array.from(pieceObjects.keys())) remove3DPiece(id);
    for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p=boardState[r][c]; if (p) make3DPiece(p); }
  }
  rebuildAllPieces();

  // ====== UI helpers ======
  function log(s){ logEl.textContent += s + "\n"; logEl.scrollTop = logEl.scrollHeight; }
  function updateTurnPill(){ turnText.textContent = turn.charAt(0).toUpperCase()+turn.slice(1); turnText.style.color = turn==='white'? '#9bd0ff' : '#ff8a8a'; }
  function showPieceInfo(p){ pieceInfo.innerHTML = `<b>Selected:</b> ${p.color} ${p.type.toUpperCase()}<br/><b>Pokémon:</b> ${p.line[p.stage-1]} (Stage ${p.stage})<br/><b>XP:</b> ${p.xp} — evolves at ${XP_THRESHOLDS.filter(x=>x>p.xp)[0] || 'max'}`; }

  function pushHistory(){ history.push({board: deepClone(boardState), turn, lastMove: lastMove? {...lastMove}:null}); }
  function popHistory(){ if (!history.length) return; const prev=history.pop(); boardState=prev.board; turn=prev.turn; lastMove=prev.lastMove; selected=null; legal=[]; updateTurnPill(); rebuildAllPieces(); setSquareHighlight(); setLegalHighlights([]); }

  function maybeEvolve(piece, {animate=true}={}){ for (let i=0;i<XP_THRESHOLDS.length;i++){ if (piece.stage===i+1 && piece.xp>=XP_THRESHOLDS[i]){ piece.stage=Math.min(3,piece.stage+1); if (animate) piece.anim={type:'evolve', start:performance.now()}; } } }

  function symbolFor(p){ const map={king:'K', queen:'Q', rook:'R', bishop:'B', knight:'N', pawn:''}; return (p.color==='white'?'♙':'♟︎') + map[p.type]; }
  function evaluateEndStates(){ const their=turn; const [kr,kc]=locateKing(boardState,their); const inChk=isSquareAttacked(boardState,kr,kc,opposite(their)); let hasMoves=false; outer: for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p=boardState[r][c]; if (!p||p.color!==their) continue; if (generateMoves(boardState,p).length){ hasMoves=true; break outer; } } if (inChk && !hasMoves){ log(`Checkmate! ${opposite(their)} wins.`); return 'Checkmate'; } else if (!inChk && !hasMoves){ log(`Stalemate! Draw.`); return 'Stalemate'; } else if (inChk){ log(`${their} is in check.`); return 'Check'; } return ''; }

  function makeMove(fr,fc,tr,tc){
    pushHistory(); const moving=boardState[fr][fc]; const target=boardState[tr][tc];
    boardState[tr][tc] = {...moving, row:tr, col:tc, hasMoved:true, anim:{type:'move', start:performance.now(), dx:(tc-fc), dy:(tr-fr)}}; boardState[fr][fc]=null;
    let note = `${symbolFor(moving)}${algebra(fc,fr)}→${algebra(tc,tr)}`;
    if (target){ boardState[tr][tc].xp += 1; note += ` x ${symbolFor(target)}`; const piece=boardState[tr][tc]; maybeEvolve(piece,{animate:true}); if (piece.anim && piece.anim.type==='evolve'){ note += ` — evolved to ${piece.line[piece.stage-1]}!`; } remove3DPiece(target.id); }
    if (moving.type==='pawn' && ((moving.color==='white'&&tr===0)||(moving.color==='black'&&tr===7))){ const evolvedLine = PokeLines[moving.color]['queen']; const p = boardState[tr][tc]; p.type='queen'; p.line=evolvedLine; p.stage=3; p.anim={type:'evolve', start:performance.now()}; note += ` — <promoted to Queen (${evolvedLine[2]})>`; }
    lastMove = {from:[fr,fc], to:[tr,tc]}; turn = opposite(turn); updateTurnPill();
    setSquareHighlight(); setLegalHighlights([]);
    const end = evaluateEndStates(); if (end){ note += ` — ${end}`; }
    log(note);
  }

  // ====== Picking ======
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  function pickSquare(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const hits = raycaster.intersectObjects(squares, false);
    if (hits.length){ const m=hits[0].object; return [m.userData.r, m.userData.c]; }
    return null;
  }

  canvas.addEventListener('mousedown', (e)=>{ const hit = pickSquare(e.clientX, e.clientY); if (!hit) return; const [r,c]=hit; handleClick(r,c); });

  function handleClick(r,c){
    const p=boardState[r][c];
    if (selected){
      const legalHere = legal.some(([lr,lc])=>lr===r&&lc===c);
      if (legalHere){ makeMove(selected.row, selected.col, r, c); selected=null; legal=[]; return; }
      if (p && p.color===turn){ selected=p; legal=generateMoves(boardState,p); showPieceInfo(p); setSquareHighlight(r,c,0x8ae3ff); setLegalHighlights(legal, 0xffff66); return; }
      selected=null; legal=[]; pieceInfo.textContent=''; setSquareHighlight(); setLegalHighlights([]); return;
    }
    if (p && p.color===turn){ selected=p; legal=generateMoves(boardState,p); showPieceInfo(p); setSquareHighlight(r,c,0x8ae3ff); setLegalHighlights(legal, 0xffff66); }
  }

  // ====== Controls ======
  document.getElementById('newGameBtn').addEventListener('click', ()=>{ boardState=startingPosition(); history=[]; selected=null; legal=[]; lastMove=null; turn='white'; logEl.textContent=''; updateTurnPill(); rebuildAllPieces(); setSquareHighlight(); setLegalHighlights([]); log('New 3D game started.'); });
  document.getElementById('undoBtn').addEventListener('click', ()=> popHistory());
  document.getElementById('flipBtn').addEventListener('click', ()=>{ flipped=!flipped; camera.position.x*=-1; camera.position.z*=-1; camera.lookAt(0,BOARD_Y,0); });
  document.getElementById('toggleSpritesBtn').addEventListener('click', (e)=>{ useSprites=!useSprites; for (const g of pieceObjects.values()){ g.children.forEach(ch=>{ if (ch.isSprite) ch.visible = useSprites; }); } e.target.textContent = `Sprites: ${useSprites?'On':'Off'}`; });

  // ====== Tests ======
  function assert(name, condition){ const ok = !!condition; const msg = `${ok?'✅ PASS':'❌ FAIL'} — ${name}`; log(msg); if (!ok) console.warn(msg); }
  function runSelfTests(){
    log('--- Running self tests ---');
    { const b=startingPosition(); const p=b[6][0]; const moves=generateMoves(b,p).map(([r,c])=>`${r},${c}`); assert('White pawn at a2 → a3 & a4', moves.includes('5,0') && moves.includes('4,0')); }
    { const b=startingPosition(); const p=b[7][1]; const moves=generateMoves(b,p).map(([r,c])=>`${r},${c}`); assert('Knight at b1 → a3 & c3', moves.includes('5,0') && moves.includes('5,2')); }
    { const p=makePiece('pawn','white',6,0); assert('Stage 1 initially', p.stage===1); p.xp=1; maybeEvolve(p,{animate:false}); assert('Evolves to Stage 2 at 1 XP', p.stage===2); p.xp=3; maybeEvolve(p,{animate:false}); assert('Evolves to Stage 3 at 3 XP', p.stage===3); }
    { const b=makeEmptyBoard(); b[7][4]=makePiece('king','white',7,4); b[0][4]=makePiece('king','black',0,4); b[7][0]=makePiece('rook','black',7,0); assert('White king at e1 attacked by black rook at a1', isSquareAttacked(b,7,4,'black')); }
    log('--- Tests complete ---');
  }
  document.getElementById('runTestsBtn').addEventListener('click', runSelfTests);

  // ====== Resize & render loop ======
  function resize(){ const rect = boardWrap.getBoundingClientRect(); const size=Math.floor(Math.min(rect.width, rect.height)); renderer.setSize(size, size, false); camera.aspect = 1; camera.updateProjectionMatrix(); }
  window.addEventListener('resize', resize);
  resize();

  function render(){
    // per-frame updates
    for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p=boardState[r][c]; if (p) update3DPiece(p); }
    updateParticles();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
  }

  // ====== Kickoff ======
  updateTurnPill();
  log('3D mode active. Blue = White, Red = Black. Capture to gain XP and evolve.');
  runSelfTests();
  render();
})();
</script>
</body>
</html>
